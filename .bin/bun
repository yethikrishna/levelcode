#!/usr/bin/env bash

# Bun wrapper that syncs secrets from Infisical to .env.local
#
# Why this wrapper exists:
# Bun's automatic .env loading doesn't pass env vars to script subprocesses
# (e.g., drizzle-kit, tsx, etc.). This wrapper explicitly passes --env-file
# flags to ensure env vars are available everywhere.
#
# Env file precedence (later files override earlier ones):
#   1. .env.local - Main secrets from Infisical
#   2. .env.development.local - Worktree-specific overrides (ports, etc.)
#
# This wrapper:
# 1. Syncs .env.local from Infisical (with caching)
# 2. Creates symlinks in subdirectories for tools that need local .env files
# 3. Passes --env-file flags to bun so subprocesses inherit env vars

# Common bun installation paths to check
BUN_PATHS=(
    "/opt/homebrew/bin/bun"
    "/usr/local/bin/bun"
    "$HOME/.bun/bin/bun"
)

# Find the real bun executable
REAL_BUN=""
for path in "${BUN_PATHS[@]}"; do
    if [ -f "$path" ]; then
        REAL_BUN="$path"
        break
    fi
done

# Fallback: try to find bun in PATH excluding our directory
if [ -z "$REAL_BUN" ]; then
    SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
    REAL_BUN=$(PATH=$(echo "$PATH" | tr ':' '\n' | grep -v "^$SCRIPT_DIR$" | tr '\n' ':') which bun)
fi

# Function to find project root using git
find_project_root() {
    # Use git to find the repository root
    local git_root=$(git rev-parse --show-toplevel 2>/dev/null)
    if [ -n "$git_root" ]; then
        echo "$git_root"
    else
        # Fallback to current directory if not in a git repo
        echo "$(pwd)"
    fi
}

# Configuration
PROJECT_ROOT="$(find_project_root)"
ENV_LOCAL_FILE="$PROJECT_ROOT/.env.local"
ENV_DEVELOPMENT_LOCAL_FILE="$PROJECT_ROOT/.env.development.local"
CACHE_TTL_SECONDS=${INFISICAL_CACHE_TTL:-900}  # Default 15 minutes
CALLING_DIR="$(pwd)"

# Clean up any leftover temporary files
rm -f "$ENV_LOCAL_FILE.tmp" 2>/dev/null

# Function to check if .env.local cache is valid
is_cache_valid() {
    if [ ! -f "$ENV_LOCAL_FILE" ]; then
        return 1
    fi

    local cache_time=$(stat -f "%m" "$ENV_LOCAL_FILE" 2>/dev/null || stat -c "%Y" "$ENV_LOCAL_FILE" 2>/dev/null)
    local current_time=$(date +%s)
    local age=$((current_time - cache_time))

    # Check if cache has expired
    if [ $age -ge $CACHE_TTL_SECONDS ]; then
        return 1
    fi

    # Check if .infisical.json has been modified since cache was created
    if [ -f "$PROJECT_ROOT/.infisical.json" ]; then
        local infisical_time=$(stat -f "%m" "$PROJECT_ROOT/.infisical.json" 2>/dev/null || stat -c "%Y" "$PROJECT_ROOT/.infisical.json" 2>/dev/null)
        if [ $infisical_time -gt $cache_time ]; then
            return 1
        fi
    fi

    return 0
}

# Function to sync secrets from Infisical to .env.local
sync_from_infisical() {
    # Check if infisical CLI is available
    if ! command -v infisical &> /dev/null; then
        return 1
    fi

    # Check if .infisical.json exists
    if [ ! -f "$PROJECT_ROOT/.infisical.json" ]; then
        return 1
    fi

    # Set performance optimizations for Infisical
    export INFISICAL_DISABLE_UPDATE_CHECK=true

    local temp_file=$(mktemp)

    # Run infisical export in background from project root
    (cd "$PROJECT_ROOT" && infisical export > "$temp_file" 2>/dev/null; echo $? > "$temp_file.exit") &
    local pid=$!

    # Wait up to 10 seconds
    local count=0
    local exit_code=1
    while [ $count -lt 100 ]; do
        if ! kill -0 $pid 2>/dev/null; then
            wait $pid 2>/dev/null
            exit_code=$(cat "$temp_file.exit" 2>/dev/null || echo 1)
            break
        fi
        sleep 0.1
        count=$((count + 1))
    done

    # If still running, kill it (timeout)
    if kill -0 $pid 2>/dev/null; then
        kill $pid 2>/dev/null
        wait $pid 2>/dev/null
        local exit_code=124
        rm -f "$temp_file" "$temp_file.exit"
        echo "‚ö†Ô∏è  Infisical command timed out. Please check your connection or run 'infisical login'."
        return 1
    fi

    if [ "${exit_code:-1}" -eq 0 ] && [ -s "$temp_file" ]; then
        # Success - move temp file to .env.local
        mv "$temp_file" "$ENV_LOCAL_FILE"
        rm -f "$temp_file" "$temp_file.exit" 2>/dev/null
        return 0
    else
        # Command failed
        local output=$(cat "$temp_file" 2>/dev/null)
        rm -f "$temp_file" "$temp_file.exit"
        
        if echo "$output" | grep -q "Select the environment"; then
            echo "‚ö†Ô∏è  Infisical session expired or not logged in."
        else
            echo "‚ö†Ô∏è  Infisical sync failed."
        fi
        echo "   Please run: infisical login"
        return 1
    fi
}

# Create symlinks in package subdirectories pointing to root .env.local
# This allows Next.js and other tools to find env vars when running from subdirs
create_env_symlinks() {
    # Skip on Windows - symlinks require admin/Developer Mode
    case "$OSTYPE" in
        msys*|cygwin*|win32*)
            return
            ;;
    esac

    # Top-level packages (symlink: ../.env.local)
    for subdir in web cli common evals scripts sdk; do
        local link_path="$PROJECT_ROOT/$subdir/.env.local"
        if [ -d "$PROJECT_ROOT/$subdir" ] && [ ! -L "$link_path" ] && [ ! -f "$link_path" ]; then
            ln -sf ../.env.local "$link_path" 2>/dev/null || true
        fi
    done

    # Nested packages under packages/ (symlink: ../../.env.local)
    for subdir in packages/agent-runtime packages/bigquery packages/billing packages/build-tools packages/code-map packages/internal; do
        local link_path="$PROJECT_ROOT/$subdir/.env.local"
        if [ -d "$PROJECT_ROOT/$subdir" ] && [ ! -L "$link_path" ] && [ ! -f "$link_path" ]; then
            ln -sf ../../.env.local "$link_path" 2>/dev/null || true
        fi
    done
}

# Check for missing .env.local and print helpful guidance
# This helps non-Infisical users understand how to set up their environment
check_env_setup() {
    # Skip in CI environments - they set env vars directly
    if [ -n "$CI" ]; then
        return
    fi

    # If .env.local exists, we're good
    if [ -f "$ENV_LOCAL_FILE" ]; then
        return
    fi

    # Print helpful guidance
    echo "" >&2
    echo "‚ö†Ô∏è  No .env.local found at project root" >&2
    echo "" >&2
    echo "  To set up your environment:" >&2
    echo "" >&2
    echo "  üì¶ Infisical users:" >&2
    echo "     Run 'infisical login' then retry this command" >&2
    echo "" >&2
    echo "  ‚úèÔ∏è  Manual setup:" >&2
    echo "     Run 'cp .env.example .env.local' and edit with your values" >&2
    echo "     Then edit .env.local with your actual values" >&2
    echo "" >&2
}

# Build env file arguments for bun
# Bun's automatic .env loading doesn't pass vars to script subprocesses (like drizzle-kit),
# so we explicitly pass --env-file flags to ensure env vars are available everywhere.
build_env_file_args() {
    ENV_FILE_ARGS=""

    # Add .env.local if it exists
    if [ -f "$ENV_LOCAL_FILE" ]; then
        ENV_FILE_ARGS="--env-file=$ENV_LOCAL_FILE"
    fi

    # Add .env.development.local if it exists (higher precedence for worktree overrides)
    if [ -f "$ENV_DEVELOPMENT_LOCAL_FILE" ]; then
        ENV_FILE_ARGS="$ENV_FILE_ARGS --env-file=$ENV_DEVELOPMENT_LOCAL_FILE"
    fi
}

run_bun() {
    create_env_symlinks
    check_env_setup
    build_env_file_args
    # Use --env-file to ensure env vars are passed to script subprocesses
    exec "$REAL_BUN" $ENV_FILE_ARGS "$@"
}

# Main logic

# Path 1: Already running under Infisical wrapper - just exec bun
# Bun will load .env files natively
if [ -n "$NEXT_PUBLIC_INFISICAL_UP" ]; then
    run_bun "$@"
fi

# Path 2: Check if .env.local cache is valid
if is_cache_valid; then
    export NEXT_PUBLIC_INFISICAL_UP=true
    run_bun "$@"
fi

# Path 3: Try to sync from Infisical
if sync_from_infisical; then
    export NEXT_PUBLIC_INFISICAL_UP=true
    run_bun "$@"
fi

# Path 4: Sync failed but .env.local exists - use it with warning
if [ -f "$ENV_LOCAL_FILE" ]; then
    echo "   Using existing .env.local (may be stale)"
    export NEXT_PUBLIC_INFISICAL_UP=true
    run_bun "$@"
fi

# Path 5: No .env.local and no Infisical - check if .env.example exists for guidance
if [ -f "$PROJECT_ROOT/.env.example" ]; then
    echo "‚ùå No .env.local found and Infisical sync failed."
    echo ""
    echo "   To set up environment variables, either:"
    echo "   1. Copy .env.example to .env.local and fill in values"
    echo "   2. Set up Infisical: see INFISICAL_SETUP_GUIDE.md"
    echo ""
    exit 1
fi

# No .env files at all - just run bun (might be a non-project command)
run_bun "$@"
