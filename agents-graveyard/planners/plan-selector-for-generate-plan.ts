import { publisher } from '../../agents/constants'
import {
  PLACEHOLDER,
  type SecretAgentDefinition,
} from '../../agents/types/secret-agent-definition'

const definition: SecretAgentDefinition = {
  id: 'plan-selector',
  publisher,
  model: 'anthropic/claude-sonnet-4.5',
  displayName: 'Plan Selector',
  spawnerPrompt:
    'Expert at evaluating and selecting the best high-level plan from multiple generate-plan outputs based on simplicity and correctness.',
  toolNames: ['set_output'],
  spawnableAgents: [],
  inputSchema: {
    prompt: {
      type: 'string',
      description: 'The original task that was planned for',
    },
    params: {
      type: 'object',
      properties: {
        plans: {
          type: 'array',
          items: {
            type: 'object',
            properties: {
              id: { type: 'string' },
              plan: { type: 'string' },
            },
            required: ['id', 'plan'],
          },
        },
      },
    },
  },
  outputMode: 'structured_output',
  outputSchema: {
    type: 'object',
    properties: {
      reasoning: {
        type: 'string',
        description:
          'Analysis of each plan and reasoning for which is the best choice',
      },
      selectedPlanId: {
        type: 'string',
        description: 'The ID of the chosen plan',
      },
    },
    required: ['reasoning', 'selectedPlanId'],
  },
  inheritParentSystemPrompt: true,
  includeMessageHistory: true,
  instructionsPrompt: `For reference, here is the original user request:
<user_message>
${PLACEHOLDER.USER_INPUT_PROMPT}
</user_message>

You are evaluating multiple high-level plans generated by the generate-plan agent. Each plan has already been carefully crafted (generate-plan creates 5 alternatives internally and picks the best), so your job is to select the absolute best among these already-good plans.

Analyze each plan based on:

1. **Simplicity** - Which plan is the cleanest and most straightforward? Avoid over-engineering.
2. **Correctness** - Which plan most accurately addresses all user requirements without adding unnecessary features?
3. **Minimal scope** - Which plan touches the fewest files and has the least complexity?
4. **Clarity** - Which plan is easiest to understand and follow?
5. **Maintainability** - Which approach will be easiest to maintain and extend?
6. **Best practices** - Which plan best follows existing codebase patterns?
7. **User intent** - Which plan best addresses the user's intent and would surprise them the least?

Key principles:
- Satisfying the user expectations is important
- Simpler is better - we want the most straightforward solution that works
- Fewer file changes is better
- Reusing existing code is better than writing new code
- Matching existing patterns and conventions is important

For each plan, briefly evaluate strengths and weaknesses. Then use set_output to return your selection with:
- reasoning: Your analysis and why you chose the winner
- selectedPlanId: The ID of the best plan`,
}

export default definition
